# mysql

memory表比MyISAM表要快一个数量级，因为所有的数据都保存在内存中

innoDB是mysql中的一种存储引擎类型
与MyISAM表区别是， innoDB支持事务操作与外键，以及行级锁
myISAM崩溃后无法安全恢复
大部分时候innoDB速度比MyISAM快
MyISAM的索引与数据是分开的，并且是压缩过的。但InnoDB是紧密捆绑的，因此MyISAM占用内存少很多
MyISAM支持全文索引。 但如果需要用到全文索引，建议优先考虑InnoDB加上Sphinx的组合
MyISAM支持地理空间搜索
 
并发更新的，有两种锁
 一种乐观锁， cas， 查到以后根据时间戳或者版本号比较
一种悲观锁， select .. for update

show variables like ‘%timeout%'
mysql长连接下，如果长时间没有交互， 需要调试两个参数， interact_timeout 和 wait_timeout

第一章
客户端连接都会在服务器进程中拥有一个线程，服务器会负责缓存线程，不需要为每一个新建的连接创建或者销毁线程

锁策略
行级锁只在InnoDB和XtraDB等存储引擎中实现，而服务器层完全不了解存储引擎中的锁实现
事务
事务就是一组原子性的SQL查询，或者说一个独立的工作单元，事务内的语句，要么全部执行成功，要么全部执行失败
ACID Atom原子性 Consistent持久性 Isolation隔离性 Durability持久性

隔离级别
1、未提交读 2、不可重复读 3、可重复读4、串行化
可重复读是mysql默认的事务隔离级别
innodb通过多版本控制解决了幻读的问题
Write-Ahead Logging 预写式日志
mysql也支持Lock tables 和 unlock tables语句，这是服务器层实现的，和存储引擎无关
mvcc是行级锁的一个变种，但是它在很多情况下避免了加锁操作。因此开销更低
show table status like 查看mysql表状态
show status like '%innodb%';
innoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。 默认级别是可重复读，并且通过间隙锁策略防止幻读的出现。
查询日志是开销最低，精度最高的测量查询时间工具，开销可以忽略不计
explain 是通估计得到的结果，而通过计数器则是实际的测量结果
定义性能最有效的方法是响应时间。
当继续提升的成本超过收益的时候，应该停止优化
mysql不能讲BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序
find_in_set 可以用于tag属性
使用完全随机的字符串，例如md5 ，sha等。不适合作为主键，应为分布在不同的空间，会导致insert或者select很慢
完全的范式和反范式话都是不可能的。在现实世界中经常是混用，使用部分范式化的schema，缓存表。 可以考虑更新的时长和频率

innodb索引是 b+树索引
空间数据索引是 R 树索引
索引的好处
索引减少了扫描的行数
扫描将随机IO变成了顺序IO
扫描避免了临时表和排序
如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”
查询只需要扫描索引而无须回表
目前的API设计不允许MySQL将过滤条件传到存储引擎层。现在只能把数据从存储引擎拉到服务器层，再根据查询条件过滤
如果查询需要关联多张表，只有当ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序
当前导列为常量的时候，order by子句可以不满足索引的最左前缀的要求。
索引（A，ID），其中ID为主键，对于InnoDB来说 主键列已经包含在二级索引中，所以这也是冗余的
Extra列出现“using where”，这表示MySQL服务器将存储引擎返回行以后再应用where过滤条件
Extra列出现not exists，表示提前终止算法
MySQL无法再使用范围列后面的其他索引列了，但是对于”多个等值条件查询” 则没有这个限制
对于limit过大的问题
可以使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键原表获取需要的行。通过使用覆盖索引，不需要回表
select cols from profiles inner join (select primary key from profiles where x.sex=“M” order by rating limit 10000,10) as x 

MySQL使用如下三种方式应用where条件，从好到坏依次为
1、在索引中使用WHERE条件来过滤不匹配的记录。 这是在存储引擎层完成
2、使用覆盖索引扫描来返回记录，直接从索引中过滤不需要的记录并返回命中的结果，这是在MySQL服务器层完成的。
3、从数据表中返回数据，然后过滤不满足条件的记录。这是在MySQL服务层完成，MySQL需要先从数据表中读出记录然后过滤。
MySQL客户端和服务器之间的通信协议是“半双工”的，任何时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。

连接状态
sleep： 线程正在等待客户端发送新的请求
Query：线程正在执行查询或者正在将结果发送给客户端
Locked： 该线程正在等待表锁，InnoDB的行锁，并不会提现在线程状态中
Analyzing and statistics 线程正在收集存储引擎的统计信息，并生成查询的执行计划。
Copying to tmp table 一般是在做Group By 操作，要么是文件排序操作，或者是Union操作。
Sorting result 线程正在对结果集进行排序
Sending data 线程可能在多个状态之间传送数据，或者在生成结果集，或者向客户端返回数据。
MySQL并不是任何时候都基于成本优化，有时也会基于固定的规则。
MySQL的查询计划是一棵左侧深度优先树

使用用户定义变量可以优化排行榜
任何情况下应该避免使用select for update
如果数据有明显的”热点“，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中。 100个左右的分区是没有问题的。
MySQL在很多地方对于视图和表是同样对待的，不能对视图创建触发器，不能使用DROP TABLE 命令删除视图
视图是将视图的SQL和查询SQL进行合并。如果使用临时表，还需要服务器将数据保存在和视图结构一样的临时表中

如果想确保两个相关表始终有一致的数据，那么使用此外键比在应用中检查一致性的性能要高很多，

但使用外键约束，可能会导致一些死锁，并且由于没有直接方位这些表，这类的死锁问题难以排查

如果只是用外键做约束，那么通常在应用程序里实现会更好，因为外键会带来很大的额外消耗

存储过程在mysql内部执行，离数据最近，在服务器上执行还可以节省带宽和网络延迟。但调试不方便。
如果查询很小，相比这个查询执行的成本，解析和网络开销就变得非常明显。

可以使用触发器实现一些强制限制，或者某些业务逻辑。
触发器始终是针对一条记录的，而不是针对整个SQL，如果变更的数据集很大，效率就会变低

事件类似于Linux的定时任务，通常会把复杂的SQL都封装到一个存储过程中，这样事件在执行的时候只需要一个简单的CALL调用
GETLOCK来确保当前总是只有一个事件在被执行。
每个字符集都有一个默认的校验规则

服务端按照character_set_client设置的字符来传输数据和SQL语句
客户端按照character_set_connnection 来设置传输字符串
UTF-8的一个三字节子集，包含世界上所有的字符集

MySQL内部分布式事务，例如二进制日志操作和存储引擎。

判断是否命中缓存的方法很简单，将缓存存放在一个引用表，通过一个哈希值引用，包括如下因素，即查询本身，当前要查的数据库，客户端协议版本等。
如果查询语句中有一些不确定的数据时，则不会被缓存，例如日期等，最好先计算好，再写入sql语句

通常保证数据立刻并且一致地写到磁盘是很昂贵的。 如果能够冒一点磁盘写可能没有真正持久化到磁盘的风险，就可以增加并发性和减少I/O等待。

把日志缓冲写到日志文件  和 把日志刷新到持久化存储之间的不同是很重要的

选择CPU
低延时： 要做到这一点，需要高速的CPU，因为每个查询只能使用一个CPU
高吞吐：如果能

存储引擎通常把数据和索引都保存在一个大文件上，这意味着用RAID存储大量数据通常是最可行的方法

memory  
swpd列显示多少块被换出到磁盘，剩下的三个列显示了多少块是空闲的，多少块正在被用作缓冲，多少正在被用作操作系统的缓存
swap
si和so表示多少块正在被换入和换出
io
显示多少块设备读取和写出（bi）和bo，这通常反应了硬盘的IO
system
显示了每秒中断（in）interrupt 和上下文切换的数量 (context switch)

复制概述
1、基于行的复制
2、基于语句的复制
默认情况下使用的是基于语句的复制方式，但如果发现语句无法被正确地复制，就切换到基于行的复制方式。
把主库上把数据更改记录到二进制日志中，备库将主库的日志复制到自己的中继日志中，备库读取中继日志中的事件，将其重放到备库数据之上

备库启动I/O线程跟主库建立连接。主库发送信号量通知其有新的事件时才会被唤醒。
这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。

几乎没有基于行复制模式无法处理的场景，包括对于所有的SQL构造、触发器、存储过程等都能正确执行。但无法判断执行了哪些SQL

将备库提升为主库理论是
1、停止向老的主库写入
2、让备库追赶上主库
3、将一台备库配置为新的主库
4、将备库和写操作指向新的主库，然后开启主库的写入

禁止在更新数据的语句中使用LIMIT

按功能拆分
数据分片是首选，分区键通常是数据库中非常重要的实体的主键
如果有多个分区键，则意味着数据在系统中至少需要存储两份

当数据库有多台时，就需要全局唯一ID
UUID的值并不适合作为主键，因为不连续，导致插入效率慢
Hibernate Shards是一个支持分片的数据库抽象层

向外扩展和向内扩展
向内扩展，清理无用的数据

主从数据库
基于会话分离/基于版本分离
基于会话分离：如果用户在最近一段时间内修改了，则总是指向主库
基于版本分离：如果用户更改了，则版本号会更新，简化了脏数据检查
大多数方案都要监控延迟来决策读查询的分配
通过ARP协议快速且原子的更改ip

使用mysql的长连接并不是个好主意，除非网络不稳定，或者大量短查询占用

长连接和连接池都会在重用连接， 连接池不会导致进程过多
但连接池是在进程间排队和共享连接，而长连接是在每个进程基础上创建，不会再进程间共享
连接数过多而过载

apcu就是一种共享内存
进程内缓存  本地缓存，采用小一些的本地缓存
进程间缓存  apcu
分布式缓冲 redis

基于版本号的缓存


1、唯一键是唯一标识一条记录的，可以为空。 一个表中可以有多个唯一键
主键也是唯一标识一条记录的，但不能为空。一个表中只有一个主键

2、联合索引包含最左侧的索引 。  (a,b,c) 包含a,(a,b),(a,b,c)
3、非等值条件导致使用不了索引。
4、in中接的不能太多。or会导致扫描全表，in不能太多。该用union all，可以命中索引
5、简单的sql比较容易用到sql cache，并且减少锁表时间，并能发挥多核cpu 
6、聚集索引与非聚集索引：
聚集索引确定表中数据的物理顺序。类似与电话簿。 由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列(组合索引）。 聚集索引对于进场要搜索范围值的列特别有效。 在找到第一个值后，可以确保包含后续索引值的行在物理相邻。 同样，如果对表中检索的数据进行排序时经常要用到某一列，也可以将该列上聚集(物理排序)，避免每次查询时都进行排序。 使用唯一雇员ID列 查找特定雇员的快速方法，是在id列上创建聚集索引。 
非聚集索引，一种索引，该索引中索引的逻辑顺序与磁盘上的物理存储顺序不同。 
若把索引理解成树，那么聚集索引在叶节点上存储的就是记录。
而非聚集索引在叶节点上存储的是指向数据块的指针。

1、磁盘读取数据花费的时间可分为寻道时间、旋转延迟传输时间
寻道时间是磁臂移动到指定磁道所需要的时间，直流磁盘在5ms以下。
旋转延迟时间是指磁盘转速。 每分钟7200次，则 1/120/2=4.17ms
传输时间可以忽略不计。      即一次磁盘io时间在9ms左右。
每一次IO读取的数据我们称之为一页(page),具体一页有多大数据跟操作系统有关，一般为4k或8k。一次IO时，不光把当前磁盘地址的数据，相邻的数据也都读取到内存缓冲区内。
2、索引的作用就是把磁盘IO次数控制到一个很小量级。
3、三层B+数可以做到百万的数据量。即百万量级的数据只需要三次IO。
4、索引的区分度。 count(distinct *)/count(*)。join时，尽量选择区分度高的列。
5、mysql中，%匹配任意字符任意次数， _匹配单个任意字符。 这两个是通配符，而不是正则表达式。
6、sql中正则表达式 regexp 。正则表达式中 .表示任意单个字符 []表示任意几个钟一个
7、mysql转义需要两个\\，正则表达式一个，mysql也需要一个
8、[:digit:]表示数字
10、count(*)表示所有行、count(colomn）表示所有非null的行数
11、如果select中指定了表达式，那么在group by中也需要指定表达式。不能使用别名。
12、having过滤分组。  where 过滤行
13、作为计算字段使用子查询。
14、MyISAM和InnoDB数据库引擎。 MyISAM支持全文检索。InnoDB不支持
15、FULLTEXT(Column)  全文检索。必须给被索引的列建立索引。
select item from yx_pay where match(Column) against (“ hazy”)。 全文检索会对结果排序。有较高等级的较早返回。
16、全文检索时，可以指定已扩展模式，即返回相关的记录（词意义相近）。  WITH QUREY EXTENTION
17、全文检索时，可以指定布尔文本模式。 IN BOOLEAN  MODE
18、InnoDB支持事务， 不支持全文索引。 而MyISAM支持全文索引。不支持事务。 Memory等于MYISam所有数据在内存中，因此比较快。不同引擎中支持混用。 MYISAM由于其性能和特性因此可能是最受欢迎的数据库。
19、视图。重用sql，简化复杂的sql语句。 保护数据访问权限,过滤不想要的字段。  视图可以与表一起使用。 视图可以嵌套。视图主要用户查询。
20、视图，隐藏复杂的sql。 create view name  as select 。。、
21、存储过程。为了实现某个功能而批量执行的sql。效率比单独执行sql要高。 存储过程的特点，简单、安全、高性能。
22、create procedure timeAvg()
begin
select avg(time)  as timeAvgItem from timeTable
end;
23、call procedure(@fafe）@fefe表示变量。 执行后，可以使用select @fafe显示变量。
24、create trigger action before insert on yx_login
for each line select “insert record”。只有表支持触发器，视图不支持。
25、每个表最多支持6个出发器。 insert、update、delect之前和之后。 
26、在触发器中，在create之后，可以通过访问new这个虚表访问新建的表。可以通过old这个虚表访问删除的表。
27、create和drop两个操作不能回退。 
28、使用保留点，savepoint。能够实现部分回退。  savepoint a。  rollback to a；
29、字符集、编码格式、校对（字符比较顺序）
30、show grant for 查看某个人的权限。 
31、analyze table 分析表。 check table 检查表。repair table 修复表
32、使用多条 select+or比使用or性能高。
33、不要在列上进行运算。 例如where date(time) <2014-07-23。 这样会导致索引失效。 进行全表扫描
34、not in会导致索引失效。 从而进行全表扫描。 
35、含有NULL的列将导致索引失效，在设计表时不要让列为NULL。
36、强制mysql使用某一索引。  forec index(column)。  select * from yx_login force index(id);
37、mysql的索引类型有两种， B+树和哈希索引。 B+树从root节点开始，只能匹配最左最前的。  哈希索引对每一行进行哈希。只能实现 in操作，不能实现大于小于等操作。 但查找非常快速。除非碰撞率很高。 哈希索引不能排序，因为它不是按序存储的。 
 38、insert delayed into table。客户端插入后返回ok状态给客户端。 但没有立即插入，而是在内存中排队。等mysql有空时再插入。 坏处是不能返回自增ID，并且系统崩溃时，数据会丢失。 
select high priority  * from table1;
select low priority * from table;
39、查询缓冲区。 同样的sql可以直接返回结果，只要没有过期。 
如果长期不用的sql，应该关闭缓冲区。 
40、InnoDB支持行级锁，支持事务。不支持全文检索。 比myisam慢
41、memory数据库引擎是 hash索引。 
42、show profile
43、MyISAM 是表级锁、InnodB、Falcon是行级锁。 MVCC 行级锁带有时间戳，行级锁并发高，但开销大，所以InnodDB性能不如MYISAM。
Multi-Version Concurrency Control 
44、mysql的MyiSam引擎。 字符串都是压缩索引的(前缀压缩）。 例如perfom与performance， 将存储成（7,ance)。 因此索引需要从头开始查找。顺序查找性能比较差，但索引大小会相差很多。 ，避免使用字符串做标识位。 
45、完全随机的字符串，会导致select与insert的效率变差。 会造成磁盘随机访问，分页等问题，以及聚集索引碎片的问题。 
46、select查询，逻辑上相邻的行分布在磁盘和内存的各个地方。 
47、自适应hash索引。 当发现频繁访问innodb时，在b+树的顶部建立hash索引。 保存在内存中。 
48、where条件中， 位于表达式和函数中的列，不会使用索引。 
49、索引选择性： 索引中不重复的行与所有行的比例。 
50、不能在order by和group by中使用前缀索引。 因为前缀只是一部分。 当需要索引很长的字符串时，索引会很大并且很慢。 
51、聚集索引不是一种索引类型，而是一种索引存储方式。
52、InnoDB支持聚集索引。 聚集索引一个表中只能有一个。即一个B+树加上叶子节点的数据。
53、聚集索引把相关的数据都存放在同一颗B+树。例如按照id索引，id相同的数据存放在相邻的几个页面。 
优点：能极大提升 IO密集型的请求。但如果数据能装入内存，则用处不大。 
缺点：数据插入代价高。依赖主键顺序插入，索引更新代价高，没插入一行时，都会涉及到记录的移动。 第二索引需要查找两次，因为第二索引存放的时主键值（不是记录的地址，因此有可能很大，主键值比记录地址大）。因此在查找到主键后，还需要通过主键找到存储的行。
54、包含满足所有查询条件的索引叫做覆盖索引。
55、优化最重要的 就是减少访问的行数。
56、覆盖索引。需要返回的所有列都在索引中，并且 select *会使覆盖索引失效     
57、all和in，在逻辑上意义是一样的。 但是mysql会给in里面的值排序，然后去二分查找某个值是否在其中，而or就不会。 效率为 log(n)。
58、当mysql不能利用索引进行排序时，就需要在内存或者磁盘中进行排序，这种叫做文件排序，虽然没有用到文件。使用快速排序进行排序。  双路排序，先读取行指针和排序列，进行排序。然后第二次读取表，根据排序结果读取对应的行并输出。因此需要读两次表，第二次读取的时候会产生大量的随机IO，对系统压力较大。好处是占用空间较少。，单路排序，读取全部的行进入内存排序。 占用空间较多。
59、缓存命中率不高时，原因1、是否查询可以缓存，2、是否有频繁的update3、查询缓冲是否开启。
60、flush query cache。减少缓存碎片。
61、锁分1、共享锁，即读锁 2、修改锁，表示要修改3、独占锁，排斥其他的锁。 数据库中修改锁分两步1、使用共享锁读取数据2、再将共享锁升级成独占所。独占锁修改数据，这样有可能造成死锁的情况。即两个事物都对同一个事物申请了共享锁，并且同时要升级成独占锁时，就会等待对方释放资源。这个时候就体现了修改锁的必要了
62、mysql事务隔离级别。 1、读取未提交内容，未提交的内容也能读到2、读取已提交的内容3、可重读，在并发读取时，能读取到一致的内容。存在幻读的问题4、可串行化，强制事务排序，使之不可能冲突，即加上共享锁。