# mysql

## 存储引擎

### Memory

memory表引擎比MyISAM表引擎要快一个数量级，因为所有的数据都保存在内存中

### MyISAM

- 索引与数据是分开的，并且是压缩过的。因此MyISAM占用内存少很多
- 支持全文索引。 但如果需要用到全文索引，建议优先考虑InnoDB加上Sphinx的组合
- 支持地理空间搜索
- 崩溃后无法安全恢复

### InnoDB

- 支持事务操作与外键
- 支持行级锁
- 大部分时候速度比MyISAM快
- 索引与数据是紧密捆绑的

## 锁

- 乐观锁: cas, 查到以后根据时间戳或者版本号比较
- 悲观锁: select .. for update

## 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元，事务内的语句，要么全部执行成功，要么全部执行失败, ACID Atom原子性 Consistent持久性 Isolation隔离性 Durability持久性

## 隔离级别

- 未提交读: 读取未提交内容，未提交的内容也能读到
- 不可重复读: 读取已提交的内容
- 可重复读: 并发读取时，能读取到一致的内容。存在幻读的问题, 默认事务隔离级别
- 串行化: 强制事务排序，使之不可能冲突，即加上共享锁。

mysql不能讲BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序

## 索引

- innodb索引: B+树索引
- 空间数据索引: R树索引

- 聚集索引: 在叶节点上存储的就是记录
  - 优点：能极大提升 IO密集型的请求。但如果数据能装入内存，则用处不大
  - 缺点：数据插入代价高。依赖主键顺序插入，索引更新代价高，没插入一行时，都会涉及到记录的移动
- 非聚集索引: 该索引中索引的逻辑顺序与磁盘上的物理存储顺序不同。在叶节点上存储的是指向数据块的指针

索引的好处:

- 减少了扫描的行数
- 将随机IO变成了顺序IO
- 扫描避免了临时表和排序

- 覆盖索引: 索引包含所有需要查询的字段的值，查询只需要扫描索引而无须回表

Extra列出现“using where”，这表示MySQL服务器将存储引擎返回行以后再应用where过滤条件, where条件索引优化:

- 在索引中使用WHERE条件来过滤不匹配的记录。 这是在存储引擎层完成
- 使用覆盖索引扫描来返回记录，直接从索引中过滤不需要的记录并返回命中的结果，这是在MySQL服务器层完成的。
- 从数据表中返回数据，然后过滤不满足条件的记录。这是在MySQL服务层完成，MySQL需要先从数据表中读出记录然后过滤。

## 连接状态

- Sleep： 线程正在等待客户端发送新的请求
- Query：线程正在执行查询或者正在将结果发送给客户端
- Locked： 该线程正在等待表锁，InnoDB的行锁，并不会提现在线程状态中
- Analyzing and statistics 线程正在收集存储引擎的统计信息，并生成查询的执行计划。
- Copying to tmp table 一般是在做Group By 操作，要么是文件排序操作，或者是Union操作。
- Sorting result 线程正在对结果集进行排序
- Sending data 线程可能在多个状态之间传送数据，或者在生成结果集，或者向客户端返回数据。

## 存储过程与触发器

- 可以使用触发器实现一些强制限制，或者某些业务逻辑。
- 触发器始终是针对一条记录的，而不是针对整个SQL，如果变更的数据集很大，效率就会变低
- 存储过程在mysql内部执行，离数据最近，在服务器上执行还可以节省带宽和网络延迟。但调试不方便。
- MySQL在很多地方对于视图和表是同样对待的，不能对视图创建触发器，不能使用DROP TABLE 命令删除视图

## 最佳实践

- 任何情况下应该避免使用select for update
- 如果数据有明显的”热点“，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中
- 如果是用外键做约束，那么通常在应用程序里实现会更好，因为外键会带来很大的额外消耗, 并且可能造成死锁
- 当数据库有多台时，就需要全局唯一ID, UUID的值并不适合作为主键，因为不连续，导致插入效率慢
- 使用完全随机的字符串，例如md5 ，sha等。不适合作为主键，应为分布在不同的空间，会导致insert或者select很慢
- 完全的范式和反范式话都是不可能的。在现实世界中经常是混用，使用部分范式化的schema，缓存表。 可以考虑更新的时长和频率
- 三层B+数可以做到百万的数据量。即百万量级的数据只需要三次IO
- 索引的区分度。 count(distinct *)/count(*)。join时，尽量选择区分度高的列
- where条件中， 位于表达式和函数中的列，不会使用索引
- 长连接和连接池都会在重用连接， 连接池不会导致进程过多, 但连接池是在进程间排队和共享连接，而长连接是在每个进程基础上创建, 不会再进程间共享
- 优化最重要的就是减少访问的行数。
- 不要在列上进行运算, 这样会导致索引失效。 进行全表扫描
- 含有NULL的列将导致索引失效，在设计表时不要让列为NULL。
- in中接的不能太多。or会导致扫描全表，in不能太多。该用union all，可以命中索引
- 索引（A，ID），其中ID为主键，对于InnoDB来说 主键列已经包含在二级索引中，所以这也是冗余的
- 当mysql不能利用索引进行排序时，就需要在内存或者磁盘中进行排序，这种叫做文件排序，虽然没有用到文件。使用快速排序进行排序。  
- 如果查询需要关联多张表，只有当ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序

## 复制

主从复制过程是主库上把数据更改记录到二进制日志中，备库将主库的日志复制到自己的中继日志中，备库读取中继日志中的事件，将其重放到备库数据之上, 备库启动I/O线程跟主库建立连接。主库发送信号量通知其有新的事件时才会被唤醒。这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。

- 基于行的复制: 可以处理全部场景（SQL构造、触发器、存储过程等）, 但无法判断执行了哪些SQL
- 基于语句的复制: 默认复制方式

主从分离:  

- 基于会话分离/基于版本分离
- 基于会话分离：如果用户在最近一段时间内修改了，则总是指向主库
- 基于版本分离：如果用户更改了，则版本号会更新，简化了脏数据检查

大多数方案都要监控延迟来决策读查询的分配

