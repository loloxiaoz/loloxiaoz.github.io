# mysql

memory表比MyISAM表要快一个数量级，因为所有的数据都保存在内存中

innoDB是mysql中的一种存储引擎类型
与MyISAM表区别是， innoDB支持事务操作与外键，以及行级锁
myISAM崩溃后无法安全恢复
大部分时候innoDB速度比MyISAM快
MyISAM的索引与数据是分开的，并且是压缩过的。但InnoDB是紧密捆绑的，因此MyISAM占用内存少很多
MyISAM支持全文索引。 但如果需要用到全文索引，建议优先考虑InnoDB加上Sphinx的组合
MyISAM支持地理空间搜索
 
并发更新的，有两种锁
 一种乐观锁， cas， 查到以后根据时间戳或者版本号比较
一种悲观锁， select .. for update

show variables like ‘%timeout%'
mysql长连接下，如果长时间没有交互， 需要调试两个参数， interact_timeout 和 wait_timeout

第一章
客户端连接都会在服务器进程中拥有一个线程，服务器会负责缓存线程，不需要为每一个新建的连接创建或者销毁线程

锁策略
行级锁只在InnoDB和XtraDB等存储引擎中实现，而服务器层完全不了解存储引擎中的锁实现
事务
事务就是一组原子性的SQL查询，或者说一个独立的工作单元，事务内的语句，要么全部执行成功，要么全部执行失败
ACID Atom原子性 Consistent持久性 Isolation隔离性 Durability持久性

隔离级别
1、未提交读 2、不可重复读 3、可重复读4、串行化
可重复读是mysql默认的事务隔离级别
innodb通过多版本控制解决了幻读的问题
Write-Ahead Logging 预写式日志
mysql也支持Lock tables 和 unlock tables语句，这是服务器层实现的，和存储引擎无关
mvcc是行级锁的一个变种，但是它在很多情况下避免了加锁操作。因此开销更低
show table status like 查看mysql表状态
show status like '%innodb%';
innoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。 默认级别是可重复读，并且通过间隙锁策略防止幻读的出现。
查询日志是开销最低，精度最高的测量查询时间工具，开销可以忽略不计
explain 是通估计得到的结果，而通过计数器则是实际的测量结果
定义性能最有效的方法是响应时间。
当继续提升的成本超过收益的时候，应该停止优化
mysql不能讲BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序
find_in_set 可以用于tag属性
使用完全随机的字符串，例如md5 ，sha等。不适合作为主键，应为分布在不同的空间，会导致insert或者select很慢
完全的范式和反范式话都是不可能的。在现实世界中经常是混用，使用部分范式化的schema，缓存表。 可以考虑更新的时长和频率

innodb索引是 b+树索引
空间数据索引是 R 树索引
索引的好处
索引减少了扫描的行数
扫描将随机IO变成了顺序IO
扫描避免了临时表和排序
如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”
查询只需要扫描索引而无须回表
目前的API设计不允许MySQL将过滤条件传到存储引擎层。现在只能把数据从存储引擎拉到服务器层，再根据查询条件过滤
如果查询需要关联多张表，只有当ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序
当前导列为常量的时候，order by子句可以不满足索引的最左前缀的要求。
索引（A，ID），其中ID为主键，对于InnoDB来说 主键列已经包含在二级索引中，所以这也是冗余的
Extra列出现“using where”，这表示MySQL服务器将存储引擎返回行以后再应用where过滤条件
Extra列出现not exists，表示提前终止算法
MySQL无法再使用范围列后面的其他索引列了，但是对于”多个等值条件查询” 则没有这个限制
对于limit过大的问题
可以使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键原表获取需要的行。通过使用覆盖索引，不需要回表
select cols from profiles inner join (select primary key from profiles where x.sex=“M” order by rating limit 10000,10) as x 

MySQL使用如下三种方式应用where条件，从好到坏依次为
1、在索引中使用WHERE条件来过滤不匹配的记录。 这是在存储引擎层完成
2、使用覆盖索引扫描来返回记录，直接从索引中过滤不需要的记录并返回命中的结果，这是在MySQL服务器层完成的。
3、从数据表中返回数据，然后过滤不满足条件的记录。这是在MySQL服务层完成，MySQL需要先从数据表中读出记录然后过滤。
MySQL客户端和服务器之间的通信协议是“半双工”的，任何时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。

连接状态
sleep： 线程正在等待客户端发送新的请求
Query：线程正在执行查询或者正在将结果发送给客户端
Locked： 该线程正在等待表锁，InnoDB的行锁，并不会提现在线程状态中
Analyzing and statistics 线程正在收集存储引擎的统计信息，并生成查询的执行计划。
Copying to tmp table 一般是在做Group By 操作，要么是文件排序操作，或者是Union操作。
Sorting result 线程正在对结果集进行排序
Sending data 线程可能在多个状态之间传送数据，或者在生成结果集，或者向客户端返回数据。
MySQL并不是任何时候都基于成本优化，有时也会基于固定的规则。
MySQL的查询计划是一棵左侧深度优先树

使用用户定义变量可以优化排行榜
任何情况下应该避免使用select for update
如果数据有明显的”热点“，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中。 100个左右的分区是没有问题的。
MySQL在很多地方对于视图和表是同样对待的，不能对视图创建触发器，不能使用DROP TABLE 命令删除视图
视图是将视图的SQL和查询SQL进行合并。如果使用临时表，还需要服务器将数据保存在和视图结构一样的临时表中

如果想确保两个相关表始终有一致的数据，那么使用此外键比在应用中检查一致性的性能要高很多，

但使用外键约束，可能会导致一些死锁，并且由于没有直接方位这些表，这类的死锁问题难以排查

如果只是用外键做约束，那么通常在应用程序里实现会更好，因为外键会带来很大的额外消耗

存储过程在mysql内部执行，离数据最近，在服务器上执行还可以节省带宽和网络延迟。但调试不方便。
如果查询很小，相比这个查询执行的成本，解析和网络开销就变得非常明显。

可以使用触发器实现一些强制限制，或者某些业务逻辑。
触发器始终是针对一条记录的，而不是针对整个SQL，如果变更的数据集很大，效率就会变低

事件类似于Linux的定时任务，通常会把复杂的SQL都封装到一个存储过程中，这样事件在执行的时候只需要一个简单的CALL调用
GETLOCK来确保当前总是只有一个事件在被执行。
每个字符集都有一个默认的校验规则

服务端按照character_set_client设置的字符来传输数据和SQL语句
客户端按照character_set_connnection 来设置传输字符串
UTF-8的一个三字节子集，包含世界上所有的字符集

MySQL内部分布式事务，例如二进制日志操作和存储引擎。

判断是否命中缓存的方法很简单，将缓存存放在一个引用表，通过一个哈希值引用，包括如下因素，即查询本身，当前要查的数据库，客户端协议版本等。
如果查询语句中有一些不确定的数据时，则不会被缓存，例如日期等，最好先计算好，再写入sql语句

通常保证数据立刻并且一致地写到磁盘是很昂贵的。 如果能够冒一点磁盘写可能没有真正持久化到磁盘的风险，就可以增加并发性和减少I/O等待。

把日志缓冲写到日志文件  和 把日志刷新到持久化存储之间的不同是很重要的

选择CPU
低延时： 要做到这一点，需要高速的CPU，因为每个查询只能使用一个CPU
高吞吐：如果能

存储引擎通常把数据和索引都保存在一个大文件上，这意味着用RAID存储大量数据通常是最可行的方法

memory  
swpd列显示多少块被换出到磁盘，剩下的三个列显示了多少块是空闲的，多少块正在被用作缓冲，多少正在被用作操作系统的缓存
swap
si和so表示多少块正在被换入和换出
io
显示多少块设备读取和写出（bi）和bo，这通常反应了硬盘的IO
system
显示了每秒中断（in）interrupt 和上下文切换的数量 (context switch)

复制概述
1、基于行的复制
2、基于语句的复制
默认情况下使用的是基于语句的复制方式，但如果发现语句无法被正确地复制，就切换到基于行的复制方式。
把主库上把数据更改记录到二进制日志中，备库将主库的日志复制到自己的中继日志中，备库读取中继日志中的事件，将其重放到备库数据之上

备库启动I/O线程跟主库建立连接。主库发送信号量通知其有新的事件时才会被唤醒。
这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。

几乎没有基于行复制模式无法处理的场景，包括对于所有的SQL构造、触发器、存储过程等都能正确执行。但无法判断执行了哪些SQL

将备库提升为主库理论是
1、停止向老的主库写入
2、让备库追赶上主库
3、将一台备库配置为新的主库
4、将备库和写操作指向新的主库，然后开启主库的写入

禁止在更新数据的语句中使用LIMIT

按功能拆分
数据分片是首选，分区键通常是数据库中非常重要的实体的主键
如果有多个分区键，则意味着数据在系统中至少需要存储两份

当数据库有多台时，就需要全局唯一ID
UUID的值并不适合作为主键，因为不连续，导致插入效率慢
Hibernate Shards是一个支持分片的数据库抽象层

向外扩展和向内扩展
向内扩展，清理无用的数据

主从数据库
基于会话分离/基于版本分离
基于会话分离：如果用户在最近一段时间内修改了，则总是指向主库
基于版本分离：如果用户更改了，则版本号会更新，简化了脏数据检查
大多数方案都要监控延迟来决策读查询的分配
通过ARP协议快速且原子的更改ip

使用mysql的长连接并不是个好主意，除非网络不稳定，或者大量短查询占用

长连接和连接池都会在重用连接， 连接池不会导致进程过多
但连接池是在进程间排队和共享连接，而长连接是在每个进程基础上创建，不会再进程间共享
连接数过多而过载

apcu就是一种共享内存
进程内缓存  本地缓存，采用小一些的本地缓存
进程间缓存  apcu
分布式缓冲 redis

基于版本号的缓存