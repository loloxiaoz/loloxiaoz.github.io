# MongoDB

1、mongoDB不支持事务界别的锁定，对于某些需要自定义的“原子性”操作，可以使用server 端脚本操作，此时整个MongoDB处于锁定状态。
2、性能高、速度快： mongoDB使用C++
3、内置GridFS，支持大容量存储。本质依然是将文件分块后存储到files.file和files.chunk 2个collection中，在各个主流的driver实现中，都封装了对于GridFs的操作。由于GridFs也是一个Collection，你可以直接对文件的属性进行定义和管理。通过这些属性就可以快速找到需要的文件，轻松管理海量的文件，无需费神如何hash才能避免文件系统检索性能问题
4、内置Sharding，提供基于Range的auto sharding机制，一个collection可按照记录的范围，分成若干个段，切分到不同的shard上，shards可以和复制结合，配合Replica sets能够实现sharding+fail-over，不同的shard之间可以负载均衡。 查询对客户端是透明的，客户端执行查询，统计、mapReduce等操作，这些会被MongoDb自动路由到后端的数据节点。这让我们关注于自己的业务。MongoDB的sharding设计能力最大可支持约20PB的数据，足以支撑一般的应用。
5、对于mongoDB的查询，更新都是围绕Array进行的，代码变得简洁，无需建表，测试时间大大缩短。 数据量约2千万，数据库300G的情况下，读写2000rps。
6、扔掉关系数据库的范式思维定义，重新设计类。服务端避免使用遍历记录这种耗时的操作，相反要用Map/Reduce来完成这种表数据的处理
7、Capped Collection，一种固定大小的集合，当集合的大小达到指定的大小时，新数据覆盖老数据。
8、对比事务安全，mongoDB更关注高的插入sudu，如果你需要加载大量低价值的业务数据，那么MongoDB将很适合你的用例。但是必须避免在要求高事务安全的场景下使用MongoDB。
9、不可靠环境保证高可用，设置副本集不仅方便而且很快，此外，使用MongoDB还可以快速、安全及自动化的实现节电故障转移。
10、需要分片并且分割你的数据库，MongoDB将很容易实现这一点。
11、非结构化数据的爆发增长。
12、不需要结构化你的数据及做join查询，MongoDB是你的首选。
13、基于位置运行更好的分析用户使用情况，从而更好的制定移动电话基础设施的投入点。
14、某些情况下MongoDB会锁住数据库，如果此时正有数百个请求，则他们会堆积起来，造成许多问题，我们使用了下面的优化方式避免锁定：
每次更新前，我们会先查询记录，查询操作会将对象放入内存，于是更新则会尽可能的迅速。
15、在使用场合下，千万级别的对象文档，近10G的数据，对有索引的ID的查询，不会比mysql慢，而对于非索引字段的查询，则是全面胜出。mysql实际上无法胜任大数据量下任意字段的查询。写入性能同样令人满意。 百万级别的数据，mongoDB基本10分钟内可以解决。
16、mongoDB占用空间大。1、空间的预分配：为避免形成过多的硬盘碎片，mongoDB每次空间不足时都会申请一大块硬盘空间，而且申请的量从64M、128、256M那样的指数递增，直到2G为单个文件的最大体积。删除记录不释放空间。
17、tps和qps， tps是（每秒传输的事务个数，包括一次消息传入和消息传出，再加上一次数据库访问。 因此只有innoDB才会有。qps是MyISAM的指标，每秒响应的请求数，即最大吞吐能力。