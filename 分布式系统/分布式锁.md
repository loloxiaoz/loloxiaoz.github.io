# 分布式锁

## 分布式锁类型

ap(consistent、available、persisent）一致性、可用性、持久性
1、ap锁 注重可用性锁
2、cp锁 注重一致性的锁

### 前提条件

- 获取锁和释放锁的性能要好
- 判断是否获得锁必须是原子性的，否则可能导致多个请求都获取到锁
- 网络中断或宕机无法释放锁时，锁必须被清除，不然会发生死锁
- 可重入一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；
- 阻塞锁和非阻塞锁，阻塞锁即没有获取到锁，则继续等待获取锁；非阻塞锁即没有获取到锁后，不继续等待，直接返回锁失败。

## 实现方式

### 数据库锁

一般很少使用数据库锁，性能不好并且容易产生死锁。

#### 基于MySQL锁表

该实现方式完全依靠数据库唯一索引来实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除这条记录。这种方式存在以下几个问题：

- 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁，因为唯一索引insert都会返回失败。
- 只能是非阻塞锁，insert失败直接就报错了，无法进入队列进行重试
- 不可重入，同一线程在没有释放锁之前无法再获取到锁

#### 采用乐观锁增加版本号

根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。

### 缓存锁

基于redis实现的分布式锁：

#### 基于setnx、expire两个命令来实现

基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。解决上述问题有两种方案

第一种是采用redis2.6.12版本以后的set，它提供了一系列选项

- EX seconds – 设置键key的过期时间，单位时秒
- PX milliseconds – 设置键key的过期时间，单位时毫秒
- NX – 只有键key不存在的时候才会设置key的值
- XX – 只有键key存在的时候才会设置key的值

第二种采用setnx()，get()，getset()实现，大体的实现过程如下：

- 线程Asetnx，值为超时的时间戳(t1)，如果返回true，获得锁。
- 线程B用get 命令获取t1，与当前时间戳比较，判断是否超时，没超时false，如果已超时执行步骤3
- 计算新的超时时间t2，使用getset命令返回t3(这个值可能其他线程已经修改过)，如果t1==t3,获得锁,如果t1!=t3说明锁被其他线程获取了
- 获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）

#### RedLock算法

redlock算法是redis作者推荐的一种分布式锁实现方式，算法的内容如下：

- 获取当前时间；
- 尝试从5个相互独立redis客户端获取锁；
- 计算获取所有锁消耗的时间，当且仅当客户端从多数节点获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁；
- 重新计算有效期时间，原有效时间减去获取锁消耗的时间；
- 删除所有实例的锁

redlock算法相对于单节点redis锁可靠性要更高，但是实现起来条件也较为苛刻。

- 必须部署5个节点才能让Redlock的可靠性更强。
- 需要请求5个节点才能获取到锁，通过Future的方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁要耗费更多时间。
- 然后由于必须获取到5个节点中的3个以上，所以可能出现获取锁冲突，即大家都获得了1-2把锁，结果谁也不能获取到锁，这个问题，redis作者借鉴了raft算法的精髓，通过冲突后在随机时间开始，可以大大降低冲突时间，但是这问题并不能很好的避免，特别是在第一次获取锁的时候，所以获取锁的时间成本增加了。
- 如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到这全部3个节点的锁才能拥有锁，难度也加大了。
- 如果出现网络分区，那么可能出现客户端永远也无法获取锁的情况，介于这种情况，下面我们来看一种更可靠的分布式锁zookeeper锁。

### zookeeper分布式锁

首先我们来了解一下zookeeper的特性，看看它为什么适合做分布式锁，zookeeper是一个为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。
数据模型：

- 永久节点：节点创建后，不会因为会话失效而消失
- 临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点
- 顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。

监视器(watcher): 当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。  
根据zookeeper的这些特性，我们来看看如何利用这些特性来实现分布式锁：

- 创建一个锁目录lock
- 希望获得锁的线程A就在lock目录下，创建临时顺序节点
- 获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁
- 线程B获取所有节点，判断自己不是最小节点，设置监听(watcher)比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”）
- 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是最小的节点，获得锁。

### 方案对比

在对比各种分布式锁技术方案时，我们通常考虑几种常见的解决方案，包括：基于数据库的锁、基于Redis的锁、基于Zookeeper的锁和基于Chubby的锁。以下是这四种技术的对比：

| 技术方案          | 适用场景                                                   | 优点                                | 缺点                                         | 使用成本                                          | 实现原理                                                                                                       |
| ----------------- | ---------------------------------------------------------- | ----------------------------------- | -------------------------------------------- | ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| 基于数据库的锁    | 当应用程序已经使用了数据库，且并发量不高的情况。           | 实现简单，可靠性高，无需额外组件。  | 性能较低，无法支持大并发，可能存在死锁问题。 | 低，如果已经有数据库，则无需额外成本。            | 通过在数据库中创建锁定记录来实现。当一个进程需要获得锁时，它会尝试插入一个锁定记录。如果成功，则表示已获得锁。 |
| 基于Redis的锁     | 需要快速、轻量级锁，且已经使用Redis的场景。                | 性能高，实现简单，支持TTL自动过期。 | 可靠性相对较低，可能存在脑裂问题。           | 低到中等，需要有Redis环境。                       | 使用Redis的SETNX命令和过期时间来实现。                                                                         |
| 基于Zookeeper的锁 | 需要高可靠性，且对性能要求不高的场景。                     | 高可靠性，支持公平锁。              | 性能较低，维护复杂。                         | 中等到高，需要有Zookeeper环境，且需要一定的维护。 | 使用Zookeeper的临时顺序节点来实现锁。                                                                          |
| 基于Chubby的锁    | Google内部使用，需要高可靠性，且有足够的资源来维护的场景。 | 高可靠性，Google维护。              | 不开源，无法直接使用，需要大量资源来维护。   | 高，需要有Chubby环境，且需要大量的维护。          | Chubby是Google的一个分布式锁服务，它使用了Paxos算法来保证一致性。                                              |

请注意，这只是一个简单的对比，实际选择使用哪一种技术方案需要根据你的具体需求和环境来决定。

redis的setnx：适合高并发场景下，用来抢占一些“唯一”的资源，例如撮合系统（redis分布式集群无法保证一致性）  
zookeeper的lock： 适合分布式任务调度场景，不适合高频次持锁时间短的抢锁的场景  
etcd的lock：使用租约、事务、事件监听和通知等机制 ，更适合做分布式锁  