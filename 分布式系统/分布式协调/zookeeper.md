# zookeeper

> 为分布式应用提供分布式的协同服务。

zk提供了一组原语，分布式系统可以根据这组原语构建更高级别的服务：比如同步、配置维护、组和命名。

## 适用的场景

- 统一配置：把配置放在ZooKeeper的节点中维护，当配置变更时，客户端可以收到变更的通知，并应用最新的配置。
- 集群管理：集群中的节点，创建ephemeral的节点，一旦断开连接，ephemeral的节点会消失，其它的集群机器可以收到消息。
- 分布式锁：多个客户端发起节点创建操作，只有一个客户端创建成功，从而获得锁。

构建正确的协同服务非常的困难，特别是那些资源竞争、死锁等情况，通过zk，分布式系统不需要从新开始构建协同服务。

## 特性

操作原语:

- create
- delete
- exists
- get data
- set data
- get chiledren
- sync

特性:

- 顺序一致性：客户端的操作会被按照顺序执行
- 原子性：操作要不失败要不成功
- 可靠性：一旦写入成功，数据就会被保持，直到下次覆盖。
- 一致性：不管连接到zk集群的那台机器，客户端看到的视图都是一致的

## 技术原理

### 模型抽象

提供一个多层级的节点命名空间（节点称为znode），每个节点都有父节点，类似于文件系统。不同的是节点都可以关联数据。

- 如何保证全局有序: 所有的更新都是全局有序的，通过唯一的时间戳（ZXid zookeeper transaction Id），写请求会发给其他的机器并达成一致后，请求才会返回成功
- 节点的分类
  - 有序节点: 子节点自增
  - 临时节点: 会话节点结束或超时后，zookeeper会自动删除该节点
- 监听事件的分类
  - 节点创建
  - 节点的删除
  - 节点的修改
  - 子节点变更
- 是否有锁定后不释放的情况: 不会，zookeeper会监听客户的心跳包判断会话是否失效，如果失效就会从临时节点删除而释放锁
- 抢占中是否有并发问题: 不会， 设置监听器和读文件子节点的操作是原子性的。 保证不会出现其他节点抢占后立即释放，当前节点仍在等待的情况。为了避免惊群效应，子节点只会监听自己前一位的子节点删除消息

### 创建分布式锁

- client创建临时且有序的子节点
- client获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听/lock的子节点变更消息（监听刚好在自己之前一位的子节点删除消息），获得子节点变更通知后重复此步骤直至获得锁
- 执行业务代码，执行完成后子节点释放锁

## 高性能的原因

内存中维护树状的目录结构，因此每个节点存放的数据上限为1M