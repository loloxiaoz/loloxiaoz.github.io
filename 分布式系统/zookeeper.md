# zookeeper

## 技术原理

1、模型抽象
提供一个多层级的节点命名空间（节点称为znode），每个节点都有父节点，类似于文件系统。不同的是节点都可以关联数据。
2、如何保证高吞吐和低延迟
内存中维护树状的目录结构，因此每个节点存放的数据上线为1M
3、如何保证全局有序性
所有的更新都是全局有序的，通过唯一的时间戳（ZXid zookeeper transaction Id），写请求会发给其他的机器并达成一致后，请求才会返回成功
4、节点的分类
有序节点，子节点自增
临时节点，会话节点结束或超时后，zookeeper会自动删除该节点
5、监听事件的分类
1、节点创建 2、节点的删除 3、节点的修改，4子节点变更
6、分布式锁创建流程
一、client创建临时且有序的子节点
二、client获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听/lock的子节点变更消息（监听刚好在自己之前一位的子节点删除消息），获得子节点变更通知后重复此步骤直至获得锁
三、执行业务代码，执行完成后子节点释放锁
7、是否有锁定后不释放的情况
不会，zookeeper会监听客户的心跳包判断会话是否失效，如果失效就会从临时节点删除而释放锁。
8、抢占过程中是否问题
不会， 设置监听器和读文件子节点的操作是原子性的。 保证不会出现其他节点抢占后立即释放，当前节点仍在等待的情况。
为了避免惊群效应，子节点只会监听自己前一位的子节点删除消息