# 缓存

## 什么是缓存

缓存就是数据交换的缓冲区。缓存的本质是一个内存 Hash。缓存是一种利用空间换时间的设计，其目标就是更快、更近：极大的提高。

- 将数据写入/读取速度更快的存储（设备）；
- 将数据缓存到离应用最近的位置；
- 将数据缓存到离用户最近的位置。

### 缓存的好处

- 提升数据读取速度。
- 提升系统扩展能力，通过扩展缓存，提升系统承载能力。
- 降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。

### 缓存淘汰策略

- 基于空间：设置缓存空间大小。
- 基于容量：设置缓存存储记录数。
- 基于时间
  - TTL（Time To Live，即存活期）缓存数据从创建到过期的时间。
  - TTI（Time To Idle，即空闲期）缓存数据多久没被访问的时间

## 缓存类型

### 前端缓存

对于静态资源，有三种方式。

根据last modified time，询问web server是否有更新，若not modified，则让浏览器使用本地缓存
根据etag标识，web server对比浏览器传过来的etag与服务器计算出的etag，若不同则返回最新的内容给浏览器。使用etag优于使用last modified time机制，毕竟基于内容算出来的标记更为靠谱。
根据expire标识，若max-age大于0，则可以使用本地缓存，完全不用请求web server

### CDN

前端项目中依赖的资源（html, js，css等），在打包后会自动上传到cdn上，从而加速用户访问。
cnd是由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以WEB Server为中心的数据传输模式。将用户的请求分配至最适合他的节点，使用户可以以最快的速度取得他所需的内容，有效解决Internet网络拥塞状况，提高用户访问的响应速度。  

优点:

- 本地Cache加速
- 跨运营商加速
- 远程加速
- 带宽优化
- 集群抗攻击

缺点:

- 不适宜缓存动态资源
- 存在数据的一致性问题

### 反向代理缓存

#### vanish  

项目中使用了varnish作为本地缓存。使用vanish将对读性能要求较高的配置类接口进行缓存（必须是get接口，并且响应的httpcode为200）。vanish在后端机器上监听8081端口，访问后端服务时，需要指定proxy为127.0.0.1:8081当本地vanish中缓存未过期时，读取缓存内容后直接返回。当缓存满时，vanish会根据LRU机制，把最旧的object释放掉。

#### nginx

Nginx使用第三方模块ncache做的缓存, 性能基本达到vanish，一般作为反向代理，可以实现简单的缓存

### 进程内缓存

进程内缓存适用于

- 数据量不大且更新频率较低的数据 
- 如果更新频繁，则需要设置较短的过期时间

#### 变量static缓存

在函数内将变量声明为static，在一次连接中可反复使用。速度快，效率高，实现简单

#### 内存缓存

直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式, 包括

- LRUHashmap
- ConcurrentHashMap
- Guava Cache

优点:

- 简单、快速
- 支持多种缓存算法
- 缓存数据有两级：内存和磁盘，无需担心容量问题

缺点:

- 占内存、磁盘空间
- 不保证数据的安全

### 分布式缓存

分布式缓存解决了进程内缓存太大的问题，如果应用是分布式系统，节点间无法共享彼此的进程内缓存。分布式缓存的应用场景

- 缓存经过复杂计算得到的数据
- 缓存系统中频繁访问的热点数据，减轻数据库压力

在某些情况下，需要使用redis这种分布式缓存，在多台机器之间缓存数据。redis提供了丰富的数据结构与查询接口，事实上redis也是我们使用比较多的缓存之一。 但如果缓存的某个数据过大，例如几十MB，反复读取也会造成redis性能的下降。

|           | 基于内存 | 数据结构       | 虚拟内存                               | 过期策略 | 数据持久 | 灾难恢复 | 性能 |
| --------- | -------- | -------------- | -------------------------------------- | -------- | -------- | -------- | ---- |
| Redis     | 是的     | List,Set等多种 | 物理内存用完可以将不用的数据交换到磁盘 | 有       | 有       | 有       | 高   |
| MemCached | 是的     | kv             | 无                                     | 有       | 无       | 无       | 高   |

Redis是一个开源（BSD许可)的，基于内存的，多数据结构存储系统，可以用作数据库、缓存和消息中间件。 Redis还可以使用分片来扩展写性能。内置了复制（replication）、LUA脚本（Lua scripting), LRU驱动事件(LRU eviction), 事务(transactions) 和不同级别的磁盘持久化，并通过Redis哨兵(Sentinel) 和自动分布（Cluster）提供高可用性(high availability)

### 进程间缓存

php5.5以后，opcache将代替apc做为php加速的位置，也就是代替其系统缓存的位置。并将用户缓存功能独立出来，开启新的组件，这个组件名称叫做apcu。使用时需要安装，并且在ini文件中加上apc.enabled=on打开。
apcu 使用共享内存机制，可以在同一台server的不同进程间缓存数据。apcu将数据缓存在内存中，相比redis等分布式缓存，省去了网络io的时间，性能会更好。 但apcu对缓存内存大小有要求。

```shell

public static function get($key, $fun, $ttl)
{
    if (!static::$isOpen || $ttl == 0) {
        return call_user_func($fun);
    }

    if (apcu_exists($key)) {
        return apcu_fetch($key);
    }
    $data = call_user_func($fun);
    if ($data) {
        apcu_store($key, $data, $ttl);
    }

    return $data;
}
```

### 编译缓存

当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码（Operate Code，opcode）。Opcode cache的目地是避免重复编译，减少CPU和内存开销。

### 数据库缓存

MySQL查询缓存可以跳过SQL解析优化查询等阶段,直接返回缓存结果给用户。当然前提比较苛刻，需要两次查询环境与sql完全一样

## 多级缓存架构

请求过程

- 浏览器向客户端发起请求，如果CDN有缓存则直接返回
- 如果CDN无缓存，则访问反向代理服务器, 如果反向代理服务器有缓存则直接返回
- 如果反向代理服务器无缓存，则访问应用服务器, 如果应用服务器有进程内缓存，则返回数据
- 如果应用服务器无缓存，则访问分布式缓存，如果分布式缓存服务器有缓存，则返回
- 如果没有缓存，应用服务器访问数据库，并将结果放入分布式缓存中

## 缓存问题

### 缓存雪崩

问题: 大量缓存同一时间内失效  
方案:  

- 增加缓存系统的可用性：例如redis cluster的主从+哨兵模式
- 采用多级缓存方案
- 限流、降级、熔断等方案
- 缓存过期时间设置为随机值
  
### 缓存穿透

问题: 查询的大量数据在数据库中不存在，那在缓存中也不存在
方案：  

- 缓存空值：对于返回为NULL的依然缓存
- 过滤不可能存在的值: 例如布隆过滤器等

### 缓存击穿

问题： 热点数据失效瞬间，大量请求直接访问数据库
方案：  

- 分布式锁： 锁住热点数据的key，避免大量线程同时访问一个key
- 定时异步刷新：失效前自动刷新缓存，而不是到期自动淘汰