# 缓存

## 什么是缓存

缓存就是数据交换的缓冲区。缓存的本质是一个内存 Hash。缓存是一种利用空间换时间的设计，其目标就是更快、更近：极大的提高。

- 将数据写入/读取速度更快的存储（设备）；
- 将数据缓存到离应用最近的位置；
- 将数据缓存到离用户最近的位置。

## 缓存的好处

- 提升数据读取速度。
- 提升系统扩展能力，通过扩展缓存，提升系统承载能力。
- 降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。

## 缓存淘汰策略

- 基于空间：设置缓存空间大小。
- 基于容量：设置缓存存储记录数。
- 基于时间
  - TTL（Time To Live，即存活期）缓存数据从创建到过期的时间。
  - TTI（Time To Idle，即空闲期）缓存数据多久没被访问的时间

## 前端缓存

对于静态资源，有三种方式。

根据last modified time，询问web server是否有更新，若not modified，则让浏览器使用本地缓存
根据etag标识，web server对比浏览器传过来的etag与服务器计算出的etag，若不同则返回最新的内容给浏览器。使用etag优于使用last modified time机制，毕竟基于内容算出来的标记更为靠谱。
根据expire标识，若max-age大于0，则可以使用本地缓存，完全不用请求web server

## CDN

前端项目中依赖的资源（html, js，css等），在打包后会自动上传到cdn上，从而加速用户访问。
cnd是由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以WEB Server为中心的数据传输模式。将用户的请求分配至最适合他的节点，使用户可以以最快的速度取得他所需的内容，有效解决Internet网络拥塞状况，提高用户访问的响应速度。  

优点:

- 本地Cache加速
- 跨运营商加速
- 远程加速
- 带宽优化
- 集群抗攻击

缺点:

- 不适宜缓存动态资源
- 存在数据的一致性问题

## 反向代理缓存

### vanish  

项目中使用了varnish作为本地缓存。使用vanish将对读性能要求较高的配置类接口进行缓存（必须是get接口，并且响应的httpcode为200）。vanish在后端机器上监听8081端口，访问后端服务时，需要指定proxy为127.0.0.1:8081当本地vanish中缓存未过期时，读取缓存内容后直接返回。当缓存满时，vanish会根据LRU机制，把最旧的object释放掉。

### nginx

Nginx使用第三方模块ncache做的缓存, 性能基本达到vanish，一般作为反向代理，可以实现简单的缓存

## 进程内缓存

### 变量static缓存

在函数内将变量声明为static，在一次连接中可反复使用。速度快，效率高，实现简单

### 内存缓存

直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式, 包括

- LRUHashmap
- ConcurrentHashMap
- Guava Cache

优点:

- 简单、快速
- 支持多种缓存算法
- 缓存数据有两级：内存和磁盘，无需担心容量问题

缺点:

- 占内存、磁盘空间
- 不保证数据的安全

## 分布式缓存

在某些情况下，需要使用redis这种分布式缓存，在多台机器之间缓存数据。redis提供了丰富的数据结构与查询接口，事实上redis也是我们使用比较多的缓存之一。 但如果缓存的某个数据过大，例如几十MB，反复读取也会造成redis性能的下降。

|       | 基于内存 | 数据结构 | 虚拟内存 | 过期策略 | 数据持久 | 灾难恢复 | 性能 |
| ----- | -------- | -------- | -------- | -------- | -------- | -------- | ---- |
| Redis |          |          |          |          |          |          |      |
|       |          |          |          |          |          |          |      |

## 进程间缓存

php5.5以后，opcache将代替apc做为php加速的位置，也就是代替其系统缓存的位置。并将用户缓存功能独立出来，开启新的组件，这个组件名称叫做apcu。使用时需要安装，并且在ini文件中加上apc.enabled=on打开。
apcu 使用共享内存机制，可以在同一台server的不同进程间缓存数据。apcu将数据缓存在内存中，相比redis等分布式缓存，省去了网络io的时间，性能会更好。 但apcu对缓存内存大小有要求。

```shell

public static function get($key, $fun, $ttl)
{
    if (!static::$isOpen || $ttl == 0) {
        return call_user_func($fun);
    }

    if (apcu_exists($key)) {
        return apcu_fetch($key);
    }
    $data = call_user_func($fun);
    if ($data) {
        apcu_store($key, $data, $ttl);
    }

    return $data;
}
```


## 编译缓存

当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码（Operate Code，opcode）。Opcode cache的目地是避免重复编译，减少CPU和内存开销。

## 数据库缓存

MySQL查询缓存可以跳过SQL解析优化查询等阶段,直接返回缓存结果给用户。当然前提比较苛刻，需要两次查询环境与sql完全一样


https://zhuanlan.zhihu.com/p/497029871?utm_id=0