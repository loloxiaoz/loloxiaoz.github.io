# 架构能力

## 架构设计原则 

- 依赖倒置(Dependency Inversion): 这一原则表明依赖的方向应该是抽象的，而不是具体实现
- 关注点分离(Separation of Concerns): 软件系统应该按照所做的工作类型来划分。比方说可以按照业务逻辑、基础设施或用户界面划分为不同的部分
- 控制反转(Inversion of Control): 由依赖注入或者依赖查找实现， 依赖不是内部生成的，而是外部传递进来的
- 依赖注入(Dependency Injection): 依赖不是内部生成的，而是外部传递进来的
- 单一职责(Single Responsibility): 每个构建块只承担唯一的责任。无论构建块的作用域是什么，是插件、包、类、函数，甚至是变量，应该只有一个职责
- DRY(Don’t Repeat Yourself): 该原则旨在通过避免重复代码来消除冗余。如果存在针对某些行为的现有功能，则应该重复使用，而不是在多个实例中拷贝相同的代码片段
- 开闭原则(Open-Closed): 软件构件应该对扩展开放，对修改关闭
- 持久化透明(Persistence Ignorance): 代码应该不受任何数据库或持久性技术的影响。业务逻辑应该与任何技术无关
- YAGNI: You ain’t gonna need it. 这一原则试图避免软件系统的过早优化
- 童子军规则(Boy Scout Rule): 在离开的时候要让露营地比来的时候更干净。当开发时遇到反模式，要坚持重构代码。随着时间的推移，这会提高代码质量
- 里氏替换原则(Liskov-Subsititution): 使用父类类型来定义对象，在运行时确定子类类型
- 封装(Encapsulation): 软件系统的不同构建块应该通过封装来限制外界对其组件的访问，通过在类范围内设置组件为私有或在插件范围内设置访问限制来实现，从而隐藏信息
- 松耦合(Loose Coupling): 软件系统的依赖关系应该松散，系统的一部分发生变化，对其他部分的影响应该最小。可以通过依赖倒置、异步消息中间件、事件源等实现
- 内聚(Cohesion): 内聚是指模块内的元素依赖的程度。某种意义上说，是对类的方法和数据以及该类所服务的某种统一目的或概念之间关系强度的度量
- 接口隔离(Interface Segregation): 将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户需要的方法
- 限界上下文(Bounded Context): 通过将大型应用程序或组织分解为单独的概念模块，提供了一种处理复杂性的方法。每个概念模块代表一个上下文，该上下文与其他上下文分离(因此是有边界的)，并且可以独立发展
- 依赖稳定原则(Stable Dependencies): 这一原则指出，软件系统的不同构建块应该只依赖于可靠、稳定的工件
- 多态(Polymorphism): 鼓励使用可以以多种形式提供的接口，多态性意味着具有多种形式的实体
- 模块化(Modularization): 模块化是将软件系统划分为多个独立模块的过程，每个模块独立工作
- 抽象(Abstraction): 在研究物体或系统时去除物理的、空间的或时间的细节或属性以集中注意力于更重要的部分，本质上与泛化过程相似
- KISS(Keep It Simple, Stupid): 保持代码简单和愚蠢(容易理解)，避免他人误解
- 增量/迭代方法(Incremental/Iterative Approach): 软件系统应该以增量和迭代的方式开发的思想，每一次迭代都会增加系统功能并保证其运行
- 最少知识原则(Least Knowledge): 软件系统的不同部分应该只拥有需要的知识


## 架构优化原则

- 从上到下: 外部网关->前端->内部网关->微服务->单功能->数据库->内存/磁盘/网络
- 从大到小: 分流->分区->分桶->异步->合并->压缩
- 从软到硬: 提高内存/磁盘/cpu/带宽
- 从业务到场景: 优化用户体验->优化使用场景->优化业务流程->优化业务架构

## 架构思维

- 技术能力
- 业务能力
- 规划能力
- 抽象能力
- 设计能力
- 学习能力
- 推动能力
- 沟通能力
- 执行能力

## 可用性

- 降级(针对自身服务): 关闭非核心业务/默认值/放弃部分请求
- 限流(针对上游服务): 滑动窗口/令牌桶/漏斗进行限流
- 熔断(针对下游服务): 根据负载阈值情况进行熔断

- 重试: 重试时机与重试次数
- 幂等: 业务一致性
- 异步: 弱一致性业务
