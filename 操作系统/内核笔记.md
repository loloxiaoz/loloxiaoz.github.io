# 内核笔记

1、Linux内核编程时，必须访问gnu c
2、Linux内核混合使用了c和汇编，在效率的地方，使用了汇编
3、Linux需要注意抢占、中断等

同步和并发, 中断提供了并发的能力

- 内核的许多特性，都要求能并发的访问数据，这就要求有同步机制保证不出现竞争条件
- 内核可以抢占
- Linux内核支持对称多处理器SMP，如果没有适度的保护，同时在两个或者两个以上的处理器上很可能会同时访问共享的同一个资源
解决的方法通常是自旋锁和信号量

## 进程

调度算法

- 先到先服务调度
- FCFS调度算法（非抢占式）
- 最短作业优先调度算法
- SJF调度算法（抢占式或非抢占式）当cpu可用时，会赋给具有最短后续CPU区间的进程
- 优先权调度算法，由优先权决定
- 轮转法调度算法

两种调度算法

- O(1) 调度算法: 在服务器上运行表现很好，但对于时间敏感型的任务不合适，因此对于交互式的系统不合适
- 完全公平算法: 是否抢占取决于新的程序消耗了多少处理器使用比，如果两个进程的nice值一样，但消耗的cpu一个比另一个少，则会立刻进行抢占。完全公平算法，每个进程都将能获得1/n的处理器时间， 但有最小处理时间，例如1ms， 避免过于频繁的切换，nice值对时间片的影响不再是算数加权，而是几何加权（相对值）

数据结构: 使用rbtree红黑树来组织可运行的进程队列，并迅速找到vruntime最小的进程进行运行，阻塞的进程被移除红黑树  
进程优先级: 是进程的价值以及对时间需求的综合打分， 有两种优先级

- 一种是nice值
- 一种是实时优先级prior（表示实时进程），如果prior那一列为-， 则表示非实时进程

## 系统调用

系统调用在硬件和用户空间的一个中间层，有三个作用

- 为用户空间提供了一个硬件的抽象接口
- 系统调用保证了系统的稳定和安全
- 实现多任务和虚拟内存

用户空间无法直接执行系统调用，通过软中断通知内核执行系统调用, 中断是由硬件引起的，而异常通常是软件，例如缺页异常, 设备驱动程序是对设备进行管理的内核程序。硬件中断的过程分为两个部分， 上半部分简单快速， 执行的时候禁止一些或者全部中断，下半部分稍后执行，而且执行期间可以相应所有的中断。

内核提供了三种不同形式的下半部实现机制： 软中断、工作队列, 只有两个子系统网络和SCSI直接使用软中断

- 当推后执行的任务需要睡眠，那么就选择工作队列
- 当推后执行的任务不需要睡眠，就选择软中断或者tasklet
- 缺省的工作者线程叫做events/n, n是处理器的编号
- 延迟linux内核处理的三种机制 1、软中断 2、tasklet 3、工作队列

## race conditions

竞争条件， 避免并发和防止竞争条件称为同步, 内核中有类似可能造成并发执行的原因

- 中断
- 软中断
- 内核抢占
- 内核及用户空间的同步
- 对称多处理器，两个或多个处理器可以同时执行代码

锁的粒度不能太粗或太细， 当锁竞争严重时， 粒度太粗会降低性能，当锁竞争不明显时，加锁过细会加大系统开销
原子性比一般的同步方法比，带给系统的开销小，对于高速缓存行的形象也小

锁的机制

- 自旋锁，持有自旋锁的时间最好小于完成两次上下文切换的耗时， 持有自选锁的时间最好小于完成两次上下文切换的耗时
- 锁保护的是数据而不是代码
- Linux中的信号量是一种睡眠锁
- 信号量适用于锁会被长时间持有的情况， 自旋锁适用于短时间的情况
- 互斥体和信号量很相似，但优先使用mutex，首选mutex
- 完成变量（completion variable） 使两个任务得以同步的简单方法
- 顺序锁（seq 锁），用于读写共享数据，序列计数器。 数据存在很多读者，数据写者很少，虽然写者很少，但是希望写优先于读， 而且不允许读者让写着饥饿

## 内存屏障

顺序与屏障， 在多处理器上， 为了提高效率，编译器和处理器可能会对读写进行重新排序, 处理器在执行指令期间，会在取指令和分派时，把表面上看似无关的指令按自认为最好的顺序排列。原子性与顺序，读必须在待定的写之前发生，属于顺序要求, 顺序性通过屏障（barrier）指令来实施
同步的目的，是编写避免竞争条件、确保正确同步，而且在多处理器上安全运行的内核代码

## 定时器与时间管理

系统定时器是一种可编程硬件芯片，能够以固定频率产生中断（节拍率），该中断就是所谓的定时器中断，它所对应的中断处理程序负责更新系统时间，也负责执行需要周期性运行的任务。Linux的节拍率为 1000， 当需要小于1ms延迟时， 通过执行数次循环达到延迟效果
MIPS（每秒处理百万条指令）

## 内存管理

2位体系结构支持4KB的页， 而64位体系结构一般支持8KB的页

- ZONE_DMA 这个区包含的页能用来执行DMA操作
- ZONE_DMA32只能被32位设备访问
- ZONE_NORMAL 这个区包含的都是能正常映射的页
- ZONE_HIGHEM 这个区包含高端内存，其中的页并不能永久映射到内核地址的空间

由malloc返回的页在进程的虚拟空间是连续的，但是这并不保证在物理的RAW中也是连续的。大多数情况，硬件设备存在于内存管理单元之外，不需要理解虚拟地址， 用到的物理地址必须是连续的, 而仅供软件使用的内存地址，则只有在虚拟地址中是连续的

slab分配器

- 频繁使用的数据结构也会频繁分配和释放，因此应当缓存它们
- 频繁分配和回收也必然导致内存碎片，空闲链表的缓存会连续地存放，避免内存碎片
- 回收的对象可以立即投入下一次分配， 因此对于频繁分配和释放，空闲链表能够提高其性能
- 如果分配器知道对象大小、页大小和总的高速缓存的大小这样的概念，它会做出更明智的决策
- 如果让部分缓存专属与单个处理器，那么分配和释放就可以在不加SMP锁的情况下进行
- 对存放的对象进行着色， 以防止多个对象映射到相同的高速缓存行

slab层把不同的对象划分为所谓的高速缓存组，其中每个高速缓存组都存放不同类型的对象。 每种对象类型对应一个高速缓存
slab层负责内存紧缺情况下所有底层的对齐、着色、分配、释放和回收等，不要自己去实现空闲链表

中断栈为每个进程提供一个用于中断处理程序的栈, 每个cpu数据会省去许多数据上锁，它唯一的安全要求就是要禁止内核抢占

- vmalloc分配的是虚拟地址上连续的页
- kmalloc分配的是物理地址上连续的页

## vfs 虚拟文件系统

虚拟的文件系统使open、read、write这样的系统调用而无须考虑具体文件系统和实际物理介质
unix使用了四种和文件系统相关的传统抽象概念

- 文件
- 目录项
- 索引节点
- 安装点

超级块对象，该对象用于存储特定文件系统的信息。

目录项有三种有效状态： 被使用、未被使用和负状态

- 负状态表示不存在状态的缓存
- dcache为目录项缓存

文件的访问呈现空间和时间的局部性，所以对目录项和索引节点进行缓存非常有益

## I/O

`I/O 调度的作用就是为上层应用发过来的IO请求做一个优化，merge and sort。 以此达到提高系统吞吐量与缩短响应时间`

使用类似于电梯调度，将请求队列按照扇区增长方向有序排列

- 最后期限I/O 调度算法并不能严格保证请求的响应时间，但是通常情况下，可以在请求超时或超时前提交和执行。 增加了读请求和写请求的超时时间
- 预测I/O 调度试图减少在进行I/O 操作期间，处理新到的读请求所带来的寻址数量。预测I/O调度程序跟踪并且统计每个应用程序的I/O操作的习惯行为，以便正确预测应用程序的未来行为
- 空操作的I/O 调度程序，专为随机访问设备而设计的
- 完全公正的调度程序

IOPS即每秒的输入输出量，也是衡量磁盘性能的主要指标之一。  the number of I/O Operations Per Second（IOPS）

- 读取10000个1kb文件，耗时10秒 Throught（吞吐量）= 1MB/s, IOPS=1000 追求IOPS
- 读取1个10MB文件， 耗时0.2秒 Throught （吞吐量）= 50MB/s， IOPS = 5 追求吞吐量

## 进程空间

一个进程的地址空间与另一个进程的地址空间、即使相同的内存地址，实际上也彼此互不相干。
一个进程可以寻址4GB的虚拟内存， 在32位的地址空间，但并不能访问所有的虚拟地址，能被进程访问的合法地址空间，称为内存地址区域
内存区域可以包含各种对象内存

- 代码段
- 数据段
- 全局变量
- 用于进程用户空间栈
- 动态库映射
- 内存映射文件
- 共享内存段
- 匿名的内存映射

地址空间使用两种不同的数据结构，存放内存区域。mm_rb红黑树用于搜索， mmap作为链表利于简单、高效地遍历所有元素

`是否共享地址空间几乎是进程和Linux中所谓的线程间本质上的唯一区别`

cache页高速缓存， Linux实现的磁盘缓存，用于减少I/O 操作， 通过把磁盘中的数据缓存到物理内存中， 把对磁盘的访问变为对物理内存的访问。缓存一般被实现成下面三种策略之一

- 第一种策略称为不缓存：不缓存写操作，当对缓存中的数据片进行写时，直接跳过缓存，写到磁盘
- 第二种写操作自动更新内存缓存，同时也更新磁盘文件。 这种方式，通常称为写透缓存，因为写操作会立刻穿透到磁盘
- 第三种策略，linux采用的，称为会写，写操作直接写到缓存中，并不会立即更新到磁盘，而是有进程定期将页高速缓存中写入的页面标记为脏

Linux实现的是一个修改过的LRU，也称为双链策略

- 活跃链表: 热的且不会被换成
- 非活跃链表:  页面则是可以被换出的

Linux 使用Radix Tree 替换了hash map， 在内存管理中利用radix树在文件内偏移快速定位文件缓存页， 基树tree路由查找值 radix tree

Radix与HashMap的比较

- Radix是针对稀疏的长整形数据查找，能够快速且节省空间的完成映射，借助Radix tree，就可以实现对于长整形数据类型的路由
- HashMap的问题
  - 需要单个全局锁保护散列表，锁争用情况严重
  - 散列表比其他方法会消耗更多的内存
